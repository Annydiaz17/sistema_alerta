# -*- coding: utf-8 -*-
"""C Diagnostico.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O_8AFDqknB3aLPtFdibUP-1YwYyQ28bk

`Sistema de Alerta Temprana y Caracterización de Estudiantes Pruebas Saber Pro Y TYT (Pruebas Diagnósticas)`

Objetivo: Analizar los resultados de los estudiantes en los 5 módulos genéricos (Razonamiento Cuantitativo, Lectura Crítica, Competencias Ciudadanas, Inglés y Comunicación Escrita).
Se utilizará K-Means para determinar los grupos de estudiantes en tres grupos y la estadística descriptiva para identificar alertas tempranas (estudiantes en riesgo) segmentados por programa académico.

` Análisis Detallado y Generación de Alertas por Programa Académico`

**Objetivo:** Determinar la estadística descriptiva (promedios, dispersión y atípicos) de manera individual para cada programa tecnológico. Identificar a los estudiantes en estado de alerta crítica y generar reportes automatizados e independientes en formato Excel para cada dirección de programa.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import glob
import warnings
warnings.filterwarnings('ignore')

print("Buscando el archivo de datos...\n")

archivos_csv = glob.glob('*.csv')

if len(archivos_csv) == 0:
    print("❌ ALERTA: No se detectó ningún archivo CSV.")
    print("Por favor arrastra tu archivo a la carpeta de Colab (icono de carpeta a la izquierda).")
else:
    archivo_datos = archivos_csv[0]
    print(f"✅ Archivo detectado y cargando: {archivo_datos}\n")

    try:
        df = pd.read_csv(archivo_datos, sep=',', on_bad_lines='skip', encoding='utf-8-sig')
        if len(df.columns) < 3:
            df = pd.read_csv(archivo_datos, sep=';', on_bad_lines='skip', encoding='utf-8-sig')

        # 2. LIMPIEZA DE DATOS AVANZADA
        columnas_puntajes = [
            'Razonamiento Cuantitativo Puntaje',
            'Lectura Crítica Puntaje',
            'Competencias Ciudadanas Puntaje',
            'Inglés Puntaje',
            'Comunicación Escrita Puntaje'
        ]
        # Limpiamos módulo por módulo
        for col in columnas_puntajes:
            if col in df.columns:
                # 1. Convertimos todo a número. Si hay letras como "IA", las vuelve un vacío (NaN)
                df[col] = pd.to_numeric(df[col], errors='coerce')
                # 2. Calculamos la mediana ignorando las letras/vacíos
                mediana_modulo = df[col].median()
                # 3. Rellenamos las inasistencias con esa mediana
                df[col] = df[col].fillna(mediana_modulo)
        # Limpiamos el Puntaje Total
        if 'Puntaje total' in df.columns:
            df['Puntaje total'] = pd.to_numeric(df['Puntaje total'], errors='coerce')
            df['Puntaje total'] = df['Puntaje total'].fillna(df['Puntaje total'].median())
        # Limpiamos el nombre del Programa
        if 'Programa:' in df.columns:
            df['Programa:'] = df['Programa:'].astype(str).str.strip()
            programas_principales = df['Programa:'].unique()

        print(f"Datos cargados y limpios correctamente. Se procesaron las 'IA'.")
        print(f"Total estudiantes: {len(df)}")
        display(df[['Número de identificación', 'Programa:', 'Puntaje total']].head())

    except Exception as e:
        print(f" Error al procesar el archivo: {e}")

""" `Estadística por Programa`
Se generará un panel visual detallado para cada programa.
* El Boxplot (Caja) mostrará la concentración de los puntajes, el promedio exacto y los puntos atípicos (estudiantes rezagados).
* Se evaluarán los 5 módulos para entender de un solo vistazo la fortaleza y la debilidad (alerta) de cada carrera.
"""

#  Preparar los datos para graficar múltiples módulos a la vez
df_melt = pd.melt(df, id_vars=['Número de identificación', 'Programa:'],
                  value_vars=columnas_puntajes,
                  var_name='Módulo', value_name='Puntaje')

df_melt['Módulo'] = df_melt['Módulo'].str.replace(' Puntaje', '')

# 2. Regla de colores para los puntos
df_melt['Estado_Alerta'] = np.where(df_melt['Puntaje'] < 120, 'Alerta Crítica (< 120)', 'Medio / Alto (>= 120)')
colores_puntos = {'Alerta Crítica (< 120)': 'red', 'Medio / Alto (>= 120)': 'green'}

columnas_niveles = [col for col in df.columns if 'Nivel de desempeño' in col]

# 3. Crear una gráfica separada por cada programa
for programa in programas_principales:
    datos_prog = df_melt[df_melt['Programa:'] == programa]
    df_original_prog = df[df['Programa:'] == programa]
    total_estudiantes = len(df_original_prog)

    if total_estudiantes == 0: continue

    plt.figure(figsize=(14, 7))

    # Boxplot y Swarmplot
    ax = sns.boxplot(x='Módulo', y='Puntaje', data=datos_prog, color='white', showfliers=False, width=0.5)
    sns.swarmplot(x='Módulo', y='Puntaje', hue='Estado_Alerta', data=datos_prog,
                  palette=colores_puntos, alpha=0.8, size=6, ax=ax)

    # Calcular MEDIA y MEDIANA
    estadisticas = datos_prog.groupby('Módulo')['Puntaje'].agg(['mean', 'median'])
    max_puntaje_programa = datos_prog['Puntaje'].max() # Puntaje más alto para saber dónde poner el texto

    for i, modulo in enumerate(datos_prog['Módulo'].unique()):
        media_val = estadisticas.loc[modulo, 'mean']
        mediana_val = estadisticas.loc[modulo, 'median']

        texto_estadistico = f'Media: {media_val:.1f}\nMediana: {mediana_val:.1f}'
        ax.text(i, max_puntaje_programa + 8, texto_estadistico,
                ha='center', va='bottom', fontweight='bold', color='darkblue',
                bbox=dict(facecolor='aliceblue', alpha=0.8, edgecolor='blue', boxstyle='round,pad=0.3'))

    # ESTIRAR EL EJE Y PARA QUE EL TEXTO NO CHOQUE CON EL TÍTULO
    ax.set_ylim(bottom=datos_prog['Puntaje'].min() - 10, top=max_puntaje_programa + 45)

    # Línea de alerta temprana
    ax.axhline(120, color='red', linestyle='--', linewidth=2, alpha=0.5, label='Umbral de Riesgo (120)')

    # Título con 'pad=25' para darle mucho espacio entre el texto y la gráfica
    plt.title(f'Desempeño Detallado: {programa.upper()})',
              fontsize=15, fontweight='bold', pad=25)

    plt.xlabel('Módulo Evaluado', fontsize=12, fontweight='bold')
    plt.ylabel('Puntaje Obtenido', fontsize=12, fontweight='bold')
    plt.xticks(rotation=15)

    plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left')
    plt.grid(axis='y', linestyle='--', alpha=0.4)
    plt.tight_layout()
    plt.show()

    if len(columnas_niveles) > 0:
        estudiantes_nivel_1 = df_original_prog[columnas_niveles].apply(lambda x: (x == 'Nivel 1').any(), axis=1).sum()
        estudiantes_nivel_2 = df_original_prog[columnas_niveles].apply(lambda x: (x == 'Nivel 2').any(), axis=1).sum()

        print(f"REPORTE DE ALERTAS - {programa.upper()} (Total Estudiantes: {total_estudiantes})")
        print(f"Estudiantes con al menos una materia en NIVEL 1: {estudiantes_nivel_1} personas.")
        print(f"Estudiantes con al menos una materia en NIVEL 2: {estudiantes_nivel_2} personas.")

    print("-" * 110)
    print("\n")

import os

print("Generando reportes individuales de Alerta Crítica en formato Excel...\n")

# Condición de Alerta: Estar en Nivel 1 en materias clave o tener un puntaje total muy bajo
condicion_alerta = (df['Nivel de desempeño Razonamiento Cuantitativo'] == 'Nivel 1') | \
                   (df['Nivel de desempeño Lectura Crítica'] == 'Nivel 1') | \
                   (df['Puntaje total'] < 130)

df_alertas_global = df[condicion_alerta]

columnas_exportar = [
    'Número de identificación',
    'Programa:',
    'Jornada:',
    'Puntaje total',
    'Razonamiento Cuantitativo Puntaje',
    'Nivel de desempeño Razonamiento Cuantitativo',
    'Lectura Crítica Puntaje',
    'Nivel de desempeño Lectura Crítica',
    'Comunicación Escrita Puntaje'
]

# Bucle para crear un archivo por programa
for programa in programas_principales:
    # Filtrar las alertas solo para el programa actual
    alertas_programa = df_alertas_global[df_alertas_global['Programa:'] == programa]

    if len(alertas_programa) > 0:
        # Seleccionar columnas y ordenar de menor a mayor puntaje
        reporte = alertas_programa[columnas_exportar].sort_values(by='Puntaje total')

        # Limpiar el nombre del programa para que no cause errores en el nombre del archivo
        nombre_limpio = programa.replace('/', '_').replace(':', '').replace(' ', '_')
        # CAMBIO 1: Modificamos la extensión de .csv a .xlsx
        nombre_archivo = f'Alertas_{nombre_limpio}.xlsx'

        # CAMBIO 2: Usamos to_excel en lugar de to_csv
        reporte.to_excel(nombre_archivo, index=False, engine='openpyxl')

        print(f"✅ Creado: {nombre_archivo} | Total estudiantes en riesgo: {len(reporte)}")
        display(reporte.head(3)) # Mostrar una pequeña vista previa
    else:
        print(f"✅ Sin riesgo crítico detectado en {programa}. (No se generó reporte)")

print("\n ¡Todos los archivos Excel (.xlsx) están listos en la pestaña de 'Archivos' (icono de carpeta a la izquierda) para ser descargados!")

"""## 5. Caracterización de Perfiles por Programa (IA: K-Means)

A diferencia de un promedio simple, el algoritmo de Machine Learning analiza a cada estudiante en un "espacio de 5 dimensiones" (evaluando los 5 módulos simultáneamente). Su objetivo es agrupar a los estudiantes que tienen comportamientos académicos similares, comparándolos exclusivamente con los compañeros de su propio programa.

El algoritmo dividirá automáticamente a los estudiantes de cada carrera en 3 perfiles:
1. **Riesgo Crítico (Rojo):** Estudiantes que el modelo detectó con falencias integrales y que requieren intervención prioritaria.
2. **Desempeño Medio (Amarillo):** El estudiante promedio del programa; aprueba, pero con oportunidades de mejora.
3. **Desempeño Superior (Verde):** El grupo de excelencia académica del programa.

Las gráficas a continuación muestran el **"Centroide"** de cada perfil. Es decir, muestran cuál es la nota promedio que saca un estudiante de Riesgo vs un estudiante Superior en cada módulo, permitiendo entender exactamente *dónde* está fallando el grupo crítico de cada carrera.
"""

# =====================================================================
# MODELO K-MEANS INDIVIDUAL POR PROGRAMA (CARACTERIZACIÓN EXPLICATIVA)
# =====================================================================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import warnings
warnings.filterwarnings('ignore')

# Columnas numéricas que alimentarán a la IA
columnas_puntajes = [
    'Razonamiento Cuantitativo Puntaje',
    'Lectura Crítica Puntaje',
    'Competencias Ciudadanas Puntaje',
    'Inglés Puntaje',
    'Comunicación Escrita Puntaje'
]

# Definimos los colores corporativos y formales para los perfiles
colores_perfiles = {
    'Riesgo Crítico': '#d73027',    # Rojo oscuro
    'Desempeño Medio': '#fee08b',   # Amarillo mostaza
    'Desempeño Superior': '#1a9850' # Verde oscuro
}

print("INICIANDO ENTRENAMIENTO DE IA (K-MEANS) POR PROGRAMA...\n")

# Bucle para entrenar un modelo K-Means diferente por cada carrera
for programa in df['Programa:'].dropna().unique():

    # 1. Aislamos los datos de un solo programa
    df_prog = df[df['Programa:'] == programa].copy()

    # Si hay muy pocos estudiantes, el algoritmo no puede crear 3 grupos lógicos
    if len(df_prog) < 10:
        print(f"Omitiendo {programa}: No hay suficientes estudiantes para perfilar con IA.")
        continue

    # 2. Preparamos los datos
    X = df_prog[columnas_puntajes]
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X) # Normalizamos

    # 3. Entrenamos el Modelo K-Means
    kmeans = KMeans(n_clusters=3, random_state=42, n_init=10)
    df_prog['Cluster_ID'] = kmeans.fit_predict(X_scaled)

    # 4. Bautizamos los perfiles basados en su rendimiento general
    # Calculamos una media total por estudiante para saber qué grupo es el alto y cuál el bajo
    df_prog['Total_Calculado'] = df_prog[columnas_puntajes].mean(axis=1)
    promedios_cluster = df_prog.groupby('Cluster_ID')['Total_Calculado'].mean().sort_values()

    # El índice 0 es el grupo con peor nota, el 2 es el de mejor nota
    etiquetas = {
        promedios_cluster.index[0]: "Riesgo Crítico",
        promedios_cluster.index[1]: "Desempeño Medio",
        promedios_cluster.index[2]: "Desempeño Superior"
    }
    df_prog['Perfil_IA'] = df_prog['Cluster_ID'].map(etiquetas)

    # 5. Calculamos el "ADN" del perfil (El centroide real)
    # Es decir, ¿cuánto saca en promedio el grupo rojo en matemáticas? ¿y en lectura?
    centroides = df_prog.groupby('Perfil_IA')[columnas_puntajes].mean().reset_index()

    # Reformateamos la tabla para que Seaborn pueda graficarla como barras agrupadas
    centroides_melt = pd.melt(centroides, id_vars='Perfil_IA', value_vars=columnas_puntajes,
                              var_name='Módulo', value_name='Puntaje_Promedio')
    centroides_melt['Módulo'] = centroides_melt['Módulo'].str.replace(' Puntaje', '')

    # VISUALIZACIÓN:

    plt.figure(figsize=(14, 6))

    # Gráfico de barras agrupadas
    ax = sns.barplot(x='Módulo', y='Puntaje_Promedio', hue='Perfil_IA', data=centroides_melt, palette=colores_perfiles)

    # Colocar los números exactos encima de cada barra
    for p in ax.patches:
        altura = p.get_height()
        if altura > 0: # Evitar barras vacías
            ax.annotate(f'{altura:.1f}',
                        (p.get_x() + p.get_width() / 2., altura),
                        ha='center', va='bottom', fontsize=9, fontweight='bold', color='black',
                        xytext=(0, 4), textcoords='offset points')

    # Línea de referencia
    plt.axhline(120, color='red', linestyle='--', linewidth=1.5, alpha=0.6, label='Umbral Crítico (120)')

    plt.title(f'Características de los Perfiles Detectados por IA\nPrograma: {programa.upper()}', fontsize=15, fontweight='bold', pad=20)
    plt.xlabel('Módulo Evaluado', fontsize=12, fontweight='bold')
    plt.ylabel('Puntaje Promedio del Perfil', fontsize=12, fontweight='bold')

    # Arreglar leyenda
    plt.legend(title='Perfil del Estudiante (K-Means)', bbox_to_anchor=(1.02, 1), loc='upper left')
    plt.ylim(0, centroides_melt['Puntaje_Promedio'].max() + 30) # Dar espacio arriba
    plt.grid(axis='y', linestyle='--', alpha=0.3)
    plt.tight_layout()
    plt.show()

    # =====================================================================
    # REPORTE TEXTUAL FORMAL
    # =====================================================================
    print(f"RESULTADOS DE LA CARACTERIZACIÓN - {programa.upper()}")
    conteo = df_prog['Perfil_IA'].value_counts()

    print(f"El algoritmo clasificó a los {len(df_prog)} estudiantes de la siguiente manera:")
    print(f"  - Perfil de Riesgo Crítico:   {conteo.get('Riesgo Crítico', 0)} estudiantes.")
    print(f"  - Perfil de Desempeño Medio:  {conteo.get('Desempeño Medio', 0)} estudiantes.")
    print(f"  - Perfil de Desempeño Superior: {conteo.get('Desempeño Superior', 0)} estudiantes.")
    print("-" * 100)
    print("\n")